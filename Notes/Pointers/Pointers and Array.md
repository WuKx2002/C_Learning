# Pointers and Array

## 1.指针与一维数组

我们知道，C语言在描述数组表示法时借助了指针。**C语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、`sizeof `或` & `的操作数时，它才表示整个数组本身。在其他的表达式中，**==**数组名会被转换为指向这个数组的指针。**==

==**这个数组有一行数据，而使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针。也就是说，数组名最终会被编译器转换为指向这个数组第一个元素的指针。**==

举个例子：

```c
int a[3] = {0, 1, 2};
```

那么在除了`sizeof `或` & `表达式中，`a`这个数组名表示的是指向这个数组（0， 1， 2这个整体）的指针，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针，也就是指向`a[0]`的指针。

由上述可知：数组名`a`是该数组首元素`a[0]`的地址，定义`a[n]`的意思是`*(a+n)`.可以认为`*(a+n)`的意思是“到内存的a位置，然后移动n个单元。（在C中，指针+1指的是增加一个存储单元，对数组而言，这意味着+1后的地址是下一个元素的地址。）

一维数组在内存中是依次排列的，如图：

<img src="https://markdown-1309501826.cos.ap-nanjing.myqcloud.com/Typora/C语言/一维数组.jpg" style="zoom:30%" />

于是，有:

`a == &a == &a[0]`

`*a == a[0]`

## 2.指针与二维数组

为了示例，我们定义一个二维数组：

```c
int a[3][4] = {
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
```

可以这样理解这个二维数组：

- `a`是一个二维数组，`a[0]`是这个二维数组的首元素。
- `a[0]`同时是一个包含了`0,1,2,3`四个`int`元素的数组。

类比一维数组，有如下事实：

- `a`的值是二维数组首元素`a[0]`的地址，即`a == &a[0] `。

  `a[0]`的值是这个一维数组首元素`a[0][0]`的地址，即` a[0] == &a[0][0]`。

- 简而言之，`a`是一个占用**4个`int`大小对象（`a[0]`）**的地址，`a[0]`是一个占用**1个`int`大小对象（`a[0][0]`）**的地址。

- ==由于这个整数（`a[0][0]`）和内含四个整数的数组（`a[0]`）都开始于同一地址，所以`a == a[0]`。==

- 综上所述，`a == a[0] == &a[0] ==  &a[0][0]`，如图：<img src="https://markdown-1309501826.cos.ap-nanjing.myqcloud.com/Typora/C语言/二维数组2.jpg" style="zoom:30%" />

==**❗ 在C中，给指针或者地址+1，其值会对应增加所指类型大小的数值**==。

```
sizeof a[0] == 16
sizeof a[0][0] == 4
```

因而`a + 1`与`a[0] + 1`不同（`a + 1`加的是4个`int`大小，`a[0] + 1`加的是1个`int`大小）。

二维数组在内存中的存储方式如图：

<img src="https://markdown-1309501826.cos.ap-nanjing.myqcloud.com/Typora/C语言/二维数组1.jpg" style="zoom:30%" />

使用解引用运算符*或者在数组名后使用带下标的[]运算符可以访问数组元素：

- `a[0]`是一维数组首元素的地址，也就是` a[0][0]`的地址，所以`*a[0] == a[0][0]`。

- 同理，`*a `代表二维数组首元素的地址，也就是`a[0]`的地址，所以`*a == a[0]`（完全相同）。

  又因为`a[0] == &a[0][0]`，所以`*a == &a[0][0]`.

- `**a == *&a[0][0] == a[0][0]`.

- `*(a+1) == a[1]`，` *a[1] == *(a+1) == a[1][0]`，`*(a+1) + 2 == a[1] + 2 == a[1][2]`

## 3. 指向数组的指针

### （1）指向一维数组的指针

```c
#include <stdio.h>

int main(void)
{
    int a[3] = {12, 14, 16};
    int * p = a;

    printf("p = %d\t", p);
    printf("a = %d\n", a);
    printf("&p = %d\t", &p);
    printf("&a = %d\n", &a);
    printf("*p = %d\t\t", *p);
    printf("*a = %d\n", *a);

    return 0;
}
```

输出：

```
p = 6422036     a = 6422036
&p = 6422024    &a = 6422036
*p = 12         *a = 12
```

`p`指向数组`a`，编译器数组名转换为指向第 0 个元素的地址，所以`*p == *a == a[0]`。

数组是一系列数据的集合，有开始和结束标志，`p` 仅仅是一个指向 `int `类型的指针，编译器不知道它指向的是一个整数还是一堆整数，对 `p `使用 `sizeof `求得的是指针变量本身的长度。也就是说，编译器并没有把` p `和数组关联起来，`p `仅仅是一个指针变量，不管它指向哪里，`sizeof` 求得的永远是它本身所占用的字节数。

站在编译器的角度讲，变量名、数组名都是一种符号，它们最终都要和数据绑定起来。变量名用来指代一份数据，数组名用来指代一组数据（数据集合），它们都是有类型的，以便推断出所指代的数据的长度。

对于数组` a`，它的类型是`int [6]`，表示这是一个拥有 6 个 `int `数据的集合，1 个 `int `的长度为 4，6 个` int `的长度为 4×6 = 24，`sizeof `很容易求得。对于指针变量` p`，它的类型是`int *`，在 32 位环境下长度为 4，在 64 位环境下长度为 8。

==**❗  归根结底，`a `和` p `这两个符号的类型不同，指代的数据也不同，它们不是一码事，`sizeof` 是根据符号类型来求长度的，`a `和 `p `的类型不同，求得的长度自然也不一样。**==

对于二维数组，也是类似的道理，例如`int a[3][3]={1, 2, 3, 4, 5, 6, 7, 8, 9};`，它的类型是`int [3][3]`，长度是 4×3×3 = 36.


###（2）指向二维数组的指针

我们先来定义一个指向 `a `的指针变量 `p`：

```c
int a[3][4] = {
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};

int (*p)[4] = a;
```

括号中的`*`表明` p `是一个指针，它指向一个数组，数组的类型为`int [4]`，这正是`a `所包含的每个一维数组的类型。

`p` 指向的数据类型是`int [4]`，那么`p+1`就前进 4×4 = 16 个字节，`p-1`就后退 16 个字节，这正好是数组 `a `所包含的每个一维数组的长度。也就是说，`p+1`会使得指针指向二维数组的下一行，`p-1`会使得指针指向数组的上一行。

==**❗  数组名 `a` 在表达式中也会被转换为和` p `等价的指针！**==

按照上面的定义：

1. `p`指向数组 a 的开头，也即第 0 行；`p+1`前进一行，指向第 1 行。

2. `*(p+1)`表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素，下面的运行结果有力地证明了这一点：

```c
#include <stdio.h>
int main(void)
{
	int a[3][4] = {
    	{0,1,2,3},
    	{4,5,6,7},
    	{8,9,10,11}
	};
    int (*p)[4] = a;
    
    printf("%d\n", sizeof(*(p+1)));
    
    return 0;
}
```

运行结果：

```c
16
```

3.  `*(p+1)`单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，**因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；**就像一维数组的名字，在定义时或者和 sizeof、& 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。

4. `*(*(p+1)+1)`表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。

根据上面的结论，可以很容易推出以下的等价关系：

```
a+i == p+i
a[i] == p[i] == *(a+i) == *(p+i)
a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)
```
### ✨难点辨析

```c
	int a[3][4] = {
        {0,1,2,3},
        {4,5,6,7},
        {8,9,10,11}
    };

    int * p = a[0];
```
令程序输出下面的值，并观察：

```
sizeof a[0] = 16        sizeof a[0][0] = 4
*a = 6421984            *p = 0
*(a + 1) = 6422000      &a[1] = 6422000
*(p + 1) = 1            a[0][1] = 1
```

==**❗  数组名 `a[0]` 在表达式中也会被转换为和` p `等价的指针！**==

`p`指向数组`a[0]`,`a[0] = {0, 1, 2, 3};` ,因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针，所以`*p = a[0][0]`。而`*(p + 1)`加的是`sizeof a[0][0]`，所以`*(p + 1) = a[0][1]`.

![](https://markdown-1309501826.cos.ap-nanjing.myqcloud.com/Typora/C语言/p指向a[0].jpg)

而`a`作为二维数组，指向的是`a[0] a[1] a[2]`这整行。同样，使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针，所以`*a = a[0]`。

![](https://markdown-1309501826.cos.ap-nanjing.myqcloud.com/Typora/C语言/a指向.jpg)

> 下面用《C Primer Plus》中的例子演示指向二维数组的指针的应用：

```c
#include <stdio.h>
int main(void)
{
    int zippo[4][2] = { {2,4}, {6,8}, {1,3}, {5, 7} };
    int (*pz)[2];
    pz = zippo;
    
    printf("   pz = %p,    pz + 1 = %p\n",
           pz,         pz + 1);
    printf("pz[0] = %p, pz[0] + 1 = %p\n",
           pz[0],      pz[0] + 1);
    printf("  *pz = %p,   *pz + 1 = %p\n",
           *pz,        *pz + 1);
    printf("pz[0][0] = %d\n", pz[0][0]);
    printf("  *pz[0] = %d\n", *pz[0]);
    printf("    **pz = %d\n", **pz);
    printf("      pz[2][1] = %d\n", pz[2][1]);
    printf("*(*(pz+2) + 1) = %d\n", *(*(pz+2) + 1));
    
    return 0;
}
```

输出：

```
   pz = 000000000061FDF0,    pz + 1 = 000000000061FDF8
pz[0] = 000000000061FDF0, pz[0] + 1 = 000000000061FDF4
  *pz = 000000000061FDF0,   *pz + 1 = 000000000061FDF4
pz[0][0] = 2
  *pz[0] = 2
    **pz = 2
      pz[2][1] = 3
*(*(pz+2) + 1) = 3
```

即`pz[m][n] == *(*(pz + m) + n)`

## 4.函数与一维数组

声明一维数组形参：

因为数组名是数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。在这种情况下，C把`int a[]`和`int * a`解释成一样。也就是说，`a`是指向`int`的指针。

由于函数原型可以省略参数名，所以下面四种原型是等价的：

```c
int f(int a[]);
int f(int [])
int f(int *a);
int f(int *);
```

但是，在函数定义中不能省略参数名。下面两种定义是等价的：

```c
int f(int a[])
{
    ...
}
int f(int *a);
{
    ...
}
```

## 5.函数与二维数组

下面我们在实例中介绍二维数组作为形式参数的声明和定义：

```c
#include <stdio.h>
#define ROWS 3
#define COLS 4
void sum_rows(int ar[][COLS], int rows);
/*
等价声明：
void sum_rows(int [][COLS], int rows);//省略参数名
void sum_rows(int (*ar)[COLS], int rows);//指针定义，ar是一个指向内含4个int数组的指针
void sum_rows(int (*)[COLS], int rows);//也可以省略参数名
*/

int main(void)
{
    int junk[ROWS][COLS] = {
        {2,4,6,8},
        {3,5,7,9},
        {12,10,8,6}
    };
    
    sum_rows(junk, ROWS);
    
    return 0;
}

void sum_rows(int ar[][COLS], int rows)//不能省略参数名
{
    int r;
    int c;
    int tot;
    
    for (r = 0; r < rows; r++)
    {
        tot = 0;
        for (c = 0; c < COLS; c++)
        {
            tot += ar[r][c];
        }
        printf("row %d: sum = %d\n", r, tot);
    }
}
/*
等价定义：
void sum_rows(int(*ar)[COLS], int rows)
{
	...
}
*/
```

==**在定义和声明时，也可以在第一个方括号中写上大小，但是编译器会忽略该值。**==

一般而言，声明一个指向N维数组的指针，只能省略最左边方括号中的值，因为第一对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指数据对象的类型。
