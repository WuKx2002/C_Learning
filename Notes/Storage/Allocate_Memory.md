##Allocate_Memory

- 存储类别有一个共同之处：在确定用哪种存储类别后，根据已制定好的内存管理规则，将自动选择其作用域和存储期。
- 静态数据在程序载入内存时分配，而自动数据在程序执行块时分配，并在程序离开该块时销毁。
- 除此之外，运用`malloc()`函数可以在程序运行时分配更多内存，该函数接受一个参数：所需的字节数。
- `malloc()`函数会找到合适的空闲内存块，这样的内存是匿名的。即`malloc()`分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此可以把该地址赋给一个指针变量，并使用指针访问这块内存。
- `malloc()`函数的返回类型通常被定义为指向char的指针。然而，从ANSI C标准开始，C使用一个新的类型：指向`void`的指针。该类型相当于一个通用指针。通常该函数的返回值会被强制转换为匹配的类型。然而，把指向`void`的指针赋给任意类型的指针完全不用考虑类型匹配的问题。如果`malloc()`分配内存失败，将返回空指针。

```c
double * ptd;
ptd = (double *) malloc(30 * sizeof(double));
```

- 回到创建数组上，现在我们有3种创建数组的方法：
  1. 声明普通数组，用常量表达式表示数组维度
  2. 声明变长数组，用变量表达式表示数组维度
  3. 调用`malloc()`函数申请数组所需存储空间

使用第2种和第3种方法可以创建动态数组。和普通数组不同，可以在程序运行时选择数组的大小和分配内存。

- 通常，`malloc()`要与`free()`配套使用。`free()`函数的参数就是之前`malloc()`返回的地址，该函数释放之前`malloc()`分配的内存。因此，动态内存分配的存储期从调用`malloc()`分配内存到调用`free()`释放内存为止。
- 不能用`free()`函数释放通过其他方式（如声明一个数组）分配的内存。
- `exit()`函数可用于结束程序。标准提供了两个返回值以保证在所有操作系统中都能正常工作（该返回值最终返回给操作系统）：EXIT_SUCCESS（或者，相当于0）表示普通程序的返回，EXIT_FAILURE表示程序异常中止，使用时以参数传递给`exit()`函数即可。
- 为保险起见，请对每一个`malloc()`函数严格配对使用`free()`函数，不要依赖操作系统来清理。

## `free()`的重要性：

1. 静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存数量只会增加，除非使用`free()`进行释放。
2. 如果没有正确释放内存，有**内存泄漏**的风险。

## `calloc()`函数

分配内存也可以使用`calloc()`。

```c
double * ptd;
ptd = (double *) calloc(30,  sizeof(double));
```

1. `calloc()`函数接受两个无符号整数作为参数（ANSI C规定是`size_t`类型），第1个参数是所需的存储单元数量，第2个参数是存储单元的大小（以字节为单位）。
2. `calloc()`函数还有一个特性：它把块中的所有位都设置为0。
3. `free()`函数也可用于释放`calloc()`分配的内存。

## 动态内存分配和变长数组

变长数组和调用`malloc()`在功能上有些重合，不同的是：

- 变长数组是自动存储类型，所以内存空间会在其离开所在块时自动释放；
- 另一方面用`malloc()`创建的数组不必局限在一个函数内访问；
- `free()`所用的指针变量不必与`malloc()`的指针变量相同（得是同一个地址，重点是地址）；
- 且不能用`free()`释放同一块内存两次。

## 存储类别和动态内存分配

- 可以认为程序把它可用的内存分为3部分：一部分具有外部链接、内部链接和无链接的静态变量使用；一部分供自动变量使用；一部分供动态内存分配。
- 总而言之，程序把静态对象、自动对象和动态分配的对象存储在不同的区域。